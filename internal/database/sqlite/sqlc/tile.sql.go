// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: tile.sql

package sqlc

import (
	"context"
)

const tileByCoordinate = `-- name: TileByCoordinate :one
SELECT 
    zoom_level, 
    tile_column, 
    tile_row, 
    tile_data
FROM tiles
WHERE tile_column=?1 AND tile_row=?2 AND zoom_level=?3
`

type TileByCoordinateParams struct {
	Col       uint64
	Row       uint64
	ZoomLevel uint64
}

func (q *Queries) TileByCoordinate(ctx context.Context, arg TileByCoordinateParams) (Tile, error) {
	row := q.db.QueryRowContext(ctx, tileByCoordinate, arg.Col, arg.Row, arg.ZoomLevel)
	var i Tile
	err := row.Scan(
		&i.ZoomLevel,
		&i.TileColumn,
		&i.TileRow,
		&i.TileData,
	)
	return i, err
}

const tileByIndex = `-- name: TileByIndex :one
SELECT
    zoom_level,
    tile_column,
    tile_row,
    tile_data
FROM tiles LIMIT 1 OFFSET ?1
`

func (q *Queries) TileByIndex(ctx context.Context, index uint64) (Tile, error) {
	row := q.db.QueryRowContext(ctx, tileByIndex, index)
	var i Tile
	err := row.Scan(
		&i.ZoomLevel,
		&i.TileColumn,
		&i.TileRow,
		&i.TileData,
	)
	return i, err
}

const tileCount = `-- name: TileCount :one
SELECT count(*) FROM tiles
`

func (q *Queries) TileCount(ctx context.Context) (uint64, error) {
	row := q.db.QueryRowContext(ctx, tileCount)
	var count uint64
	err := row.Scan(&count)
	return count, err
}

const tileDataUpdate = `-- name: TileDataUpdate :exec
UPDATE tiles 
SET tile_data=? 
WHERE tile_column=? AND tile_row=? AND zoom_level=?
`

type TileDataUpdateParams struct {
	TileData  []byte
	Col       uint64
	Row       uint64
	ZoomLevel uint64
}

func (q *Queries) TileDataUpdate(ctx context.Context, arg TileDataUpdateParams) error {
	_, err := q.db.ExecContext(ctx, tileDataUpdate,
		arg.TileData,
		arg.Col,
		arg.Row,
		arg.ZoomLevel,
	)
	return err
}

const tiles = `-- name: Tiles :many
SELECT zoom_level, tile_column, tile_row, tile_data FROM tiles
`

func (q *Queries) Tiles(ctx context.Context) ([]Tile, error) {
	rows, err := q.db.QueryContext(ctx, tiles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tile
	for rows.Next() {
		var i Tile
		if err := rows.Scan(
			&i.ZoomLevel,
			&i.TileColumn,
			&i.TileRow,
			&i.TileData,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
